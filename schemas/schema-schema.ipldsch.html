<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>IPLD Specifications</title>
    <meta name="description" content="Specifications for the Inter-planetary Linked Data project">
    
    
    <link rel="preload" href="/specs/assets/css/0.styles.e1d0aacd.css" as="style"><link rel="preload" href="/specs/assets/js/app.0a49797f.js" as="script"><link rel="preload" href="/specs/assets/js/2.1a099048.js" as="script"><link rel="preload" href="/specs/assets/js/19.793dfca8.js" as="script"><link rel="prefetch" href="/specs/assets/js/10.20d32efc.js"><link rel="prefetch" href="/specs/assets/js/11.caa89001.js"><link rel="prefetch" href="/specs/assets/js/12.d257f0be.js"><link rel="prefetch" href="/specs/assets/js/13.5d4d4dac.js"><link rel="prefetch" href="/specs/assets/js/14.1c9994f7.js"><link rel="prefetch" href="/specs/assets/js/15.3a14b740.js"><link rel="prefetch" href="/specs/assets/js/16.80268b69.js"><link rel="prefetch" href="/specs/assets/js/17.f3d4a390.js"><link rel="prefetch" href="/specs/assets/js/18.37de45dc.js"><link rel="prefetch" href="/specs/assets/js/20.21c47159.js"><link rel="prefetch" href="/specs/assets/js/3.0815f1d8.js"><link rel="prefetch" href="/specs/assets/js/4.dd356c84.js"><link rel="prefetch" href="/specs/assets/js/5.ca1edd40.js"><link rel="prefetch" href="/specs/assets/js/6.348bd51b.js"><link rel="prefetch" href="/specs/assets/js/7.ec310dab.js"><link rel="prefetch" href="/specs/assets/js/8.5326f388.js"><link rel="prefetch" href="/specs/assets/js/9.75a50e6f.js">
    <link rel="stylesheet" href="/specs/assets/css/0.styles.e1d0aacd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/specs/" class="home-link router-link-active"><!----> <span class="site-name">IPLD Specifications</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/specs/" class="nav-link">Home</a></div><div class="nav-item"><a href="/specs/schemas/" class="nav-link router-link-active">IPLD Schemas</a></div> <a href="https://github.com/ipld/specs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/specs/" class="nav-link">Home</a></div><div class="nav-item"><a href="/specs/schemas/" class="nav-link router-link-active">IPLD Schemas</a></div> <a href="https://github.com/ipld/specs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>IPLD Schemas</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/specs/schemas/goals.html" class="sidebar-link">Goals</a></li><li><a href="/specs/schemas/feature-summary.html" class="sidebar-link">Feature Summary</a></li><li><a href="/specs/schemas/introduction.html" class="sidebar-link">Introduction</a></li><li><a href="/specs/schemas/authoring-guide.html" class="sidebar-link">Authoring Guide</a></li><li><a href="/specs/schemas/links.html" class="sidebar-link">Links and IPLD Schemas</a></li><li><a href="/specs/schemas/schema-kinds.html" class="sidebar-link">IPLD Schema Kinds</a></li><li><a href="/specs/schemas/representations.html" class="sidebar-link">Representations</a></li><li><a href="/specs/schemas/advanced-layouts.html" class="sidebar-link">Advanced Layouts</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token comment">## -----</span>
<span class="token comment">## This is the schema describing the schema declarations for IPLD Schemas.</span>
<span class="token comment">## Yes, it's self-describing! :)</span>
<span class="token comment">## -----</span>

<span class="token comment">## Type names are a simple alias of string.</span>
<span class="token comment">##</span>
<span class="token comment">## There are some additional rules that should be applied. Type names:</span>
<span class="token comment">##   - *Must* only contain alphanumeric ASCII characters and underscores</span>
<span class="token comment">##   - *Must* begin with a capital letter</span>
<span class="token comment">##   - *Should* avoid more than one connected underscore character,</span>
<span class="token comment">##     multiple-underscores may be used for codegen</span>
<span class="token comment">##</span>
<span class="token comment">## Type names are strings meant for human consumption at a local scope.</span>
<span class="token comment">## When making a Schema, note that the TypeName is the key of the map:</span>
<span class="token comment">## a TypeName must be unique within the Schema.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeName</span></span> <span class="token keyword">string</span>

<span class="token comment">## SchemaMap is a complete set of types;</span>
<span class="token comment">## it is simply a map of TypeName to detailed declaration of that Type.</span>
<span class="token comment">##</span>
<span class="token comment">## A simple schema map with one type might look like this:</span>
<span class="token comment">##</span>
<span class="token comment">## ```</span>
<span class="token comment">## {</span>
<span class="token comment">##   &quot;MyFooType&quot;: {</span>
<span class="token comment">##     &quot;type&quot;: &quot;string&quot;</span>
<span class="token comment">##   }</span>
<span class="token comment">## }</span>
<span class="token comment">## ```</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">SchemaMap</span></span> <span class="token punctuation">{</span>TypeName<span class="token punctuation">:</span>Type<span class="token punctuation">}</span>

<span class="token comment">## AdvancedDataLayoutName defines the name of an ADL as a string.</span>
<span class="token comment">##</span>
<span class="token comment">## The same constraints and conventions apply as for TypeName.</span>
<span class="token comment">##</span>
<span class="token comment">## This identifier is used for keys in the AdvancedDataLayoutMap and also as</span>
<span class="token comment">## references to ADLs where the &quot;advanced&quot; representation strategy is used for</span>
<span class="token comment">## the types that support it.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">AdvancedDataLayoutName</span></span> <span class="token keyword">string</span>

<span class="token comment">## AdvancedDataLayoutMap defines the set of ADLs found within the schema. It</span>
<span class="token comment">## maps the name (AdvancedDataLayoutName) to the AdvancedDataLayout, which is</span>
<span class="token comment">## currently an empty map.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">AdvancedDataLayoutMap</span></span> <span class="token punctuation">{</span>AdvancedDataLayoutName<span class="token punctuation">:</span>AdvancedDataLayout<span class="token punctuation">}</span>

<span class="token comment">## Schema is a single-member union, which can be used in serialization</span>
<span class="token comment">## to make a form of &quot;nominative type declaration&quot;.</span>
<span class="token comment">##</span>
<span class="token comment">## A complete (if quite short) Schema might look like this:</span>
<span class="token comment">##</span>
<span class="token comment">## ```</span>
<span class="token comment">## {</span>
<span class="token comment">##   &quot;schema&quot;: {</span>
<span class="token comment">##     &quot;MyFooType&quot;: {</span>
<span class="token comment">##       &quot;type&quot;: &quot;string&quot;</span>
<span class="token comment">##     }</span>
<span class="token comment">##   }</span>
<span class="token comment">## }</span>
<span class="token comment">## ```</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Schema</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	types SchemaMap
<span class="token typedef"><span class="token keyword">	advanced</span> <span class="token class-name">AdvancedDataLayoutMap</span></span>
<span class="token punctuation">}</span>

<span class="token comment">## The types of Type are a union.</span>
<span class="token comment">##</span>
<span class="token comment">## The Type union is serialized using &quot;inline&quot; union representation,</span>
<span class="token comment">## which means all of its members have map representations, and there will be</span>
<span class="token comment">## an entry in that map called &quot;type&quot; which contains the union discriminant.</span>
<span class="token comment">##</span>
<span class="token comment">## Some of the kinds of type are so simple the union discriminant is the only</span>
<span class="token comment">## content at all, e.g. strings:</span>
<span class="token comment">##</span>
<span class="token comment">## ```</span>
<span class="token comment">## {</span>
<span class="token comment">##   &quot;type&quot;: &quot;string&quot;</span>
<span class="token comment">## }</span>
<span class="token comment">## ```</span>
<span class="token comment">##</span>
<span class="token comment">## Other types have more content.  Consider this example of a map type:</span>
<span class="token comment">##</span>
<span class="token comment">## ```</span>
<span class="token comment">## {</span>
<span class="token comment">##   &quot;type&quot;: &quot;map&quot;,</span>
<span class="token comment">##   &quot;keyType&quot;: &quot;String&quot;,</span>
<span class="token comment">##   &quot;valueType&quot;: &quot;Int&quot;</span>
<span class="token comment">## }</span>
<span class="token comment">## ```</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Type</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> TypeBool <span class="token string">&quot;bool&quot;</span>
	<span class="token punctuation">|</span> TypeString <span class="token string">&quot;string&quot;</span>
	<span class="token punctuation">|</span> TypeBytes <span class="token string">&quot;bytes&quot;</span>
	<span class="token punctuation">|</span> TypeInt <span class="token string">&quot;int&quot;</span>
	<span class="token punctuation">|</span> TypeFloat <span class="token string">&quot;float&quot;</span>
	<span class="token punctuation">|</span> TypeMap <span class="token string">&quot;map&quot;</span>
	<span class="token punctuation">|</span> TypeList <span class="token string">&quot;list&quot;</span>
	<span class="token punctuation">|</span> TypeLink <span class="token string">&quot;link&quot;</span>
	<span class="token punctuation">|</span> TypeUnion <span class="token string">&quot;union&quot;</span>
	<span class="token punctuation">|</span> TypeStruct <span class="token string">&quot;struct&quot;</span>
	<span class="token punctuation">|</span> TypeEnum <span class="token string">&quot;enum&quot;</span>
	<span class="token punctuation">|</span> TypeCopy <span class="token string">&quot;copy&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> inline <span class="token punctuation">{</span>
	discriminantKey <span class="token string">&quot;kind&quot;</span>
<span class="token punctuation">}</span>

<span class="token comment">## TypeKind enumerates all the major kinds of type.</span>
<span class="token comment">## Notice this enum's members are the same as the set of strings used as</span>
<span class="token comment">## discriminants in the Type union.</span>
<span class="token comment">##</span>
<span class="token comment">## TODO: not actually sure we'll need to declare this.  Only usage is</span>
<span class="token comment">## in the Type union representation details?</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeKind</span></span> <span class="token builtin">enum</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> Bool
	<span class="token punctuation">|</span> String
	<span class="token punctuation">|</span> Bytes
	<span class="token punctuation">|</span> Int
	<span class="token punctuation">|</span> Float
	<span class="token punctuation">|</span> Map
	<span class="token punctuation">|</span> List
	<span class="token punctuation">|</span> Link
	<span class="token punctuation">|</span> Union
	<span class="token punctuation">|</span> Struct
	<span class="token punctuation">|</span> Enum
<span class="token punctuation">}</span>

<span class="token comment">## RepresentationKind is similar to TypeKind, but includes only those concepts</span>
<span class="token comment">## which exist at the IPLD *Data Model* level.</span>
<span class="token comment">##</span>
<span class="token comment">## In other words, structs, unions, and enumerations are not present:</span>
<span class="token comment">## those concepts are introduced in the IPLD Schema system, and when serialized,</span>
<span class="token comment">## all of them must be transformable to one of these representation kinds</span>
<span class="token comment">## (e.g. a &quot;struct&quot; TypeKind will usually be transformed to a &quot;map&quot;</span>
<span class="token comment">## RepresentationKind; &quot;enum&quot; TypeKind are always &quot;string&quot; RepresentationKind;</span>
<span class="token comment">## and so on.)</span>
<span class="token comment">##</span>
<span class="token comment">## RepresentationKind strings are sometimes used to to indicate part of the</span>
<span class="token comment">## definition in the details of Type; for example, they're used describing</span>
<span class="token comment">## some of the detailed behaviors of a &quot;kinded&quot;-style union type.</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">RepresentationKind</span></span> <span class="token builtin">enum</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> Bool
	<span class="token punctuation">|</span> String
	<span class="token punctuation">|</span> Bytes
	<span class="token punctuation">|</span> Int
	<span class="token punctuation">|</span> Float
	<span class="token punctuation">|</span> Map
	<span class="token punctuation">|</span> List
	<span class="token punctuation">|</span> Link
<span class="token punctuation">}</span>

<span class="token comment">## AnyScalar defines a union of the basic non-complex kinds.</span>
<span class="token comment">##</span>
<span class="token comment">## Useful defining usage of IPLD nodes that do compose from other nodes.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">AnyScalar</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> Bool <span class="token keyword">bool</span>
	<span class="token punctuation">|</span> String <span class="token keyword">string</span>
	<span class="token punctuation">|</span> Bytes <span class="token keyword">bytes</span>
	<span class="token punctuation">|</span> Int <span class="token keyword">int</span>
	<span class="token punctuation">|</span> Float <span class="token keyword">float</span>
<span class="token representation">} <span class="token builtin">representation</span></span> kinded

<span class="token comment">## AdvancedDataLayout defines `advanced` definitions which are stored in the</span>
<span class="token comment">## top-level &quot;advanced&quot; map (AdvancedDataLayoutMap)</span>
<span class="token comment">##</span>
<span class="token comment">## Used as `advanced Foo` rather than `type Foo` to indicate an advanced data</span>
<span class="token comment">## layout (ADL) with that name which can be used as a representation for type</span>
<span class="token comment">## definitions whose kind the ADL is able to support.</span>
<span class="token comment">##</span>
<span class="token comment">## The AdvancedDataLayoutName is currently the only identifier that can be used</span>
<span class="token comment">## to make a connection with the algorithm/logic behind this ADL. Future</span>
<span class="token comment">## iterations may formalize this connection by some other means.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">AdvancedDataLayout</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">## TypeBool describes a simple boolean type.</span>
<span class="token comment">## It has no details.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeBool</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">## TypeString describes a simple string type.</span>
<span class="token comment">## It has no details.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeString</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">## TypeBytes describes a simple byte array type.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeBytes</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	representation BytesRepresentation
<span class="token punctuation">}</span>

<span class="token comment">## BytesRepresentation specifies how a TypeBytes is to be serialized. By</span>
<span class="token comment">## default it will be stored as bytes in the data model but it may be replaced</span>
<span class="token comment">## with an ADL.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">BytesRepresentation</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> BytesRepresentation_Bytes <span class="token string">&quot;bytes&quot;</span>
	<span class="token punctuation">|</span> AdvancedDataLayoutName <span class="token string">&quot;advanced&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> keyed

<span class="token comment">## BytesRepresentation_Bytes is the default representation for TypeBytes and</span>
<span class="token comment">## will be used implicitly if no representation is specified.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">BytesRepresentation_Bytes</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">## TypeInt describes a simple integer numeric type.</span>
<span class="token comment">## It has no details.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeInt</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">## TypeFloat describes a simple floating point numeric type.</span>
<span class="token comment">## It has no details.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeFloat</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">## TypeMap describes a key-value map.</span>
<span class="token comment">## The keys and values of the map have some specific type of their own.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeMap</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	keyType TypeName <span class="token comment"># additionally, the referenced type must be reprkind==string.</span>
	valueType TypeTerm
	valueNullable Bool <span class="token punctuation">(</span>implicit <span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span>
	representation MapRepresentation
<span class="token representation">} <span class="token builtin">representation</span></span> map

<span class="token comment">## MapRepresentation describes how a map type should be mapped onto</span>
<span class="token comment">## its IPLD Data Model representation.  By default a map is a map in the</span>
<span class="token comment">## Data Model but other kinds can be configured.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">MapRepresentation</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> MapRepresentation_Map <span class="token string">&quot;map&quot;</span>
	<span class="token punctuation">|</span> MapRepresentation_StringPairs <span class="token string">&quot;stringpairs&quot;</span>
	<span class="token punctuation">|</span> MapRepresentation_ListPairs <span class="token string">&quot;listpairs&quot;</span>
	<span class="token punctuation">|</span> AdvancedDataLayoutName <span class="token string">&quot;advanced&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> keyed

<span class="token comment">## MapRepresentation_Map describes that a map should be encoded as</span>
<span class="token comment">## a map in the Data Model</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">MapRepresentation_Map</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">## MapRepresentation_StringPairs describes that a map should be encoded as a</span>
<span class="token comment">## string of delimited &quot;k/v&quot; entries, e.g. &quot;k1=v1,k2=v2&quot;.</span>
<span class="token comment">## The separating delimiter may be specified with &quot;entryDelim&quot;, and the k/v</span>
<span class="token comment">## delimiter may be specified with &quot;innerDelim&quot;. So a &quot;k=v&quot; naive</span>
<span class="token comment">## comma-separated form would use an &quot;innerDelim&quot; of &quot;=&quot; and an &quot;entryDelim&quot;</span>
<span class="token comment">## of &quot;,&quot;.</span>
<span class="token comment">##</span>
<span class="token comment">## This serial representation is limited: the domain of keys must</span>
<span class="token comment">## exclude the &quot;innerDelim&quot; and values and keys must exclude &quot;,&quot;.</span>
<span class="token comment">## There is no facility for escaping, such as in escaped CSV.</span>
<span class="token comment">## This also leads to a further restriction that this representation is only</span>
<span class="token comment">## valid for maps whose keys and values may all be encoded to string form</span>
<span class="token comment">## without conflicts in delimiter character. It is recommended, therefore,</span>
<span class="token comment">## that its use be limited to maps containing values with the basic data</span>
<span class="token comment">## model kinds that exclude multiple values (i.e. no maps, lists, and therefore</span>
<span class="token comment">## structs or unions).</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">MapRepresentation_StringPairs</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	innerDelim String
	entryDelim String
<span class="token punctuation">}</span>

<span class="token comment">## MapRepresentation_ListPairs describes that a map should be encoded as a</span>
<span class="token comment">## list in the IPLD Data Model. This list comprises a sub-list for each entry,</span>
<span class="token comment">## in the form: [[k1,v1],[k2,v2]].</span>
<span class="token comment">##</span>
<span class="token comment">## This representation type is similar to StructRepresentation_Tuple except</span>
<span class="token comment">## it includes the keys. This is critical for maps since the keys are not</span>
<span class="token comment">## defined in the schema (hence &quot;tuple&quot; representation isn't available for</span>
<span class="token comment">## maps).</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">MapRepresentation_ListPairs</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">## TypeList describes a list.</span>
<span class="token comment">## The values of the list have some specific type of their own.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeList</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	valueType TypeTerm
	valueNullable Bool <span class="token punctuation">(</span>implicit <span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span>
	representation ListRepresentation
<span class="token representation">} <span class="token builtin">representation</span></span> map

<span class="token comment">## ListRepresentation describes how a map type should be mapped onto</span>
<span class="token comment">## its IPLD Data Model representation.  By default a list is a list in the</span>
<span class="token comment">## data model but it may be replaced with an ADL.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">ListRepresentation</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> ListRepresentation_List <span class="token string">&quot;list&quot;</span>
	<span class="token punctuation">|</span> AdvancedDataLayoutName <span class="token string">&quot;advanced&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> keyed

<span class="token comment">## ListRepresentation_List is the default representation for TypeList and</span>
<span class="token comment">## will be used implicitly if no representation is specified.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">ListRepresentation_List</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">## TypeLink describes a hash linking to another object (a CID).</span>
<span class="token comment">##</span>
<span class="token comment">## A link also has an &quot;expectedType&quot; that provides a hinting mechanism</span>
<span class="token comment">## suggesting what we should find if we were to follow the link. This</span>
<span class="token comment">## cannot be strictly enforced by a node or block-level schema</span>
<span class="token comment">## validation but may be enforced elsewhere in an application relying on</span>
<span class="token comment">## a schema.</span>
<span class="token comment">##</span>
<span class="token comment">## The expectedType is specified with the `&amp;Any` link shorthand, where</span>
<span class="token comment">## `Any` may be replaced with a specific type.</span>
<span class="token comment">##</span>
<span class="token comment">## Unlike other kinds, we use `&amp;Type` to denote a link Type rather than</span>
<span class="token comment">## `Link`. In this usage, we replace `Type` the expected Type, with `&amp;Any`</span>
<span class="token comment">## being shorthand for &quot;a link which may resolve to a type of any kind&quot;.</span>
<span class="token comment">##</span>
<span class="token comment">## `expectedType` is a String, but it should validate as &quot;Any&quot; or a TypeName</span>
<span class="token comment">## found somewhere in the schema.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeLink</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	expectedType String <span class="token punctuation">(</span>implicit <span class="token string">&quot;Any&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">## TypeUnion describes a union (sometimes called a &quot;sum type&quot;, or</span>
<span class="token comment">## more verbosely, a &quot;discriminated union&quot;).</span>
<span class="token comment">## A union is a type that can have a value of several different types, but</span>
<span class="token comment">## unlike maps or structs, in a union only one of those values may be present</span>
<span class="token comment">## at a time.</span>
<span class="token comment">##</span>
<span class="token comment">## Unions can be defined as representing in several different ways: see</span>
<span class="token comment">## the documentation on the UnionRepresentation type for details.</span>
<span class="token comment">##</span>
<span class="token comment">## The set of types which the union can contain are specified in a map</span>
<span class="token comment">## inside the representation field.  (The key type of the map varies per</span>
<span class="token comment">## representation strategy, so it's not possible to keep on this type directly.)</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeUnion</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	representation UnionRepresentation
<span class="token punctuation">}</span>

<span class="token comment">## UnionRepresentation is a union of all the distinct ways a TypeUnion's values</span>
<span class="token comment">## can be mapped onto a serialized format for the IPLD Data Model.</span>
<span class="token comment">##</span>
<span class="token comment">## There are five strategies that can be used to encode a union:</span>
<span class="token comment">## &quot;keyed&quot;, &quot;envelope&quot;, &quot;inline&quot;, &quot;byteprefix&quot;, and &quot;kinded&quot;.</span>
<span class="token comment">## The &quot;keyed&quot;, &quot;envelope&quot;, and &quot;inline&quot; strategies are all ways to produce</span>
<span class="token comment">## representations in a map format, using map keys as type discriminators</span>
<span class="token comment">## (some literature may describe this as a &quot;tagged&quot; style of union).</span>
<span class="token comment">## The &quot;byteprefix&quot; strategy, only available only for unions in which all</span>
<span class="token comment">## member types themselves represent as bytes in the data model, uses another</span>
<span class="token comment">## byte as the type discrimination hint (and like the map-oriented strategies,</span>
<span class="token comment">## may also be seen as a form of &quot;tagged&quot; style unions).</span>
<span class="token comment">## The &quot;kinded&quot; strategy can describe a union in which member types have</span>
<span class="token comment">## several different representation kinds, and uses the representation kind</span>
<span class="token comment">## itself as the type discrimination hint to do so.</span>
<span class="token comment">##</span>
<span class="token comment">## Note: Unions can be used to produce a &quot;nominative&quot; style of type declarations</span>
<span class="token comment">## -- yes, even given that IPLD Schema systems are natively &quot;structural&quot; typing!</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">UnionRepresentation</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> UnionRepresentation_Kinded <span class="token string">&quot;kinded&quot;</span>
	<span class="token punctuation">|</span> UnionRepresentation_Keyed <span class="token string">&quot;keyed&quot;</span>
	<span class="token punctuation">|</span> UnionRepresentation_Envelope <span class="token string">&quot;envelope&quot;</span>
	<span class="token punctuation">|</span> UnionRepresentation_Inline <span class="token string">&quot;inline&quot;</span>
	<span class="token punctuation">|</span> UnionRepresentation_BytePrefix <span class="token string">&quot;byteprefix&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> keyed

<span class="token comment">## &quot;Kinded&quot; union representations describe a bidirectional mapping between</span>
<span class="token comment">## a RepresentationKind and a Type (referenced by name) which should be the</span>
<span class="token comment">## union member decoded when one sees this RepresentationKind.</span>
<span class="token comment">##</span>
<span class="token comment">## The referenced type must of course produce the RepresentationKind it's</span>
<span class="token comment">## matched with!</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">UnionRepresentation_Kinded</span></span> <span class="token punctuation">{</span>RepresentationKind<span class="token punctuation">:</span>TypeName<span class="token punctuation">}</span>

<span class="token comment">## &quot;Keyed&quot; union representations will encode as a map, where the map has</span>
<span class="token comment">## exactly one entry, the key string of which will be used to look up the name</span>
<span class="token comment">## of the Type; and the value should be the content, and be of that Type.</span>
<span class="token comment">##</span>
<span class="token comment">## Note: when writing a new protocol, it may be wise to prefer keyed unions</span>
<span class="token comment">## over the other styles wherever possible; keyed unions tend to have good</span>
<span class="token comment">## performance characteristics, as they have most &quot;mechanical sympathy&quot; with</span>
<span class="token comment">## parsing and deserialization implementation order.</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">UnionRepresentation_Keyed</span></span> <span class="token punctuation">{</span>String<span class="token punctuation">:</span>TypeName<span class="token punctuation">}</span>

<span class="token comment">## &quot;Envelope&quot; union representations will encode as a map, where the map has</span>
<span class="token comment">## exactly two entries: the two keys should be of the exact strings specified</span>
<span class="token comment">## for this envelope representation.  The value for the discriminant key</span>
<span class="token comment">## should be one of the strings in the discriminant table.  The value for</span>
<span class="token comment">## the content key should be the content, and be of the Type matching the</span>
<span class="token comment">## lookup in the discriminant table.</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">UnionRepresentation_Envelope</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	discriminantKey String
	contentKey String
	discriminantTable <span class="token punctuation">{</span>String<span class="token punctuation">:</span>TypeName<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">## &quot;Inline&quot; union representations require that all of their members encode</span>
<span class="token comment">## as a map, and encode their type info into the same map as the member data.</span>
<span class="token comment">## Thus, the map for an inline union may have any number of entries: it is</span>
<span class="token comment">## however many fields the member value has, plus one (for the discriminant).</span>
<span class="token comment">##</span>
<span class="token comment">## All members of an inline union must be struct types and must encode to</span>
<span class="token comment">## the map RepresentationKind.  Other types which encode to map (such as map</span>
<span class="token comment">## types themselves!) cannot be used: the potential for content values with</span>
<span class="token comment">## with keys overlapping with the discriminantKey would result in undefined</span>
<span class="token comment">## behavior!  Similarly, the member struct types may not have fields which</span>
<span class="token comment">## have names that collide with the discriminantKey.</span>
<span class="token comment">##</span>
<span class="token comment">## When designing a new protocol, use inline unions sparringly; despite</span>
<span class="token comment">## appearing simple, they have the most edge cases of any kind of union</span>
<span class="token comment">## representation, and their implementation is generally the most complex and</span>
<span class="token comment">## is difficult to optimize deserialization to support.</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">UnionRepresentation_Inline</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	discriminantKey String
	discriminantTable <span class="token punctuation">{</span>String<span class="token punctuation">:</span>TypeName<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">## UnionRepresentation_BytePrefix describes a union representation for unions</span>
<span class="token comment">## whose member types are all bytes. It is encoded to a byte array whose</span>
<span class="token comment">## first byte is the discriminator and subsequent bytes form the discriminated</span>
<span class="token comment">## type.</span>
<span class="token comment">##</span>
<span class="token comment">## byteprefix is an invalid representation for any union that contains a type</span>
<span class="token comment">## that does not have a bytes representation.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">UnionRepresentation_BytePrefix</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	discriminantTable <span class="token punctuation">{</span>TypeName<span class="token punctuation">:</span>Int<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">## TypeStruct describes a type which has a group of fields of varying Type.</span>
<span class="token comment">## Each field has a name, which is used to access its value, similarly to</span>
<span class="token comment">## accessing values in a map.</span>
<span class="token comment">##</span>
<span class="token comment">## The most typical representation of a struct is as a map, in which case field</span>
<span class="token comment">## names also serve as the the map keys (though this is a default, and details</span>
<span class="token comment">## of this representation may be configured; and other representation strategies</span>
<span class="token comment">## also exist).</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeStruct</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	fields <span class="token punctuation">{</span>FieldName<span class="token punctuation">:</span>StructField<span class="token punctuation">}</span>
	representation StructRepresentation
<span class="token punctuation">}</span>

<span class="token comment">## FieldName is an alias of string.</span>
<span class="token comment">##</span>
<span class="token comment">## There are some additional rules that should be applied:</span>
<span class="token comment">##   - Field names should by convention begin with a lower-case letter;</span>
<span class="token comment">##   - Field names must be all printable characters (no whitespace);</span>
<span class="token comment">##   - Field names must not contain punctuation other than underscores</span>
<span class="token comment">##     (dashes, dots, etc.).</span>
<span class="token comment">##</span>
<span class="token comment">## Field names are strings meant for human consumption at a local scope.</span>
<span class="token comment">## When making a Schema, note that the FieldName is the key of the map:</span>
<span class="token comment">## a FieldName must be unique within the Schema.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">FieldName</span></span> <span class="token keyword">string</span>

<span class="token comment">## StructField describes the properties of each field declared by a TypeStruct.</span>
<span class="token comment">##</span>
<span class="token comment">## StructField contains properties similar to TypeMap -- namely, it describes</span>
<span class="token comment">## a content type (as a TypeTerm -- it supports inline definitions) -- and</span>
<span class="token comment">## has a boolean property for whether or not the value is permitted to be null.</span>
<span class="token comment">##</span>
<span class="token comment">## In addition, StructField also has a property called &quot;optional&quot;.</span>
<span class="token comment">## An &quot;optional&quot; field is one which is permitted to be absent entirely.</span>
<span class="token comment">## This is distinct from &quot;nullable&quot;: a field can be optional=false and</span>
<span class="token comment">## nullable=true, in which case it's an error if the key is missing entirely,</span>
<span class="token comment">## but null is of course valid.  Conversely, if a field is optional=true and</span>
<span class="token comment">## nullable=false, it's an error if the field is present and assigned null, but</span>
<span class="token comment">## fine for a map to be missing a key of the field's name entirely and still be</span>
<span class="token comment">## recognized as this struct.</span>
<span class="token comment">## (The specific behavior of optionals may vary per StructRepresentation.)</span>
<span class="token comment">##</span>
<span class="token comment">## Note that the 'optional' and 'nullable' properties are not themselves</span>
<span class="token comment">## optional... however, in the IPLD serial representation of schemas, you'll</span>
<span class="token comment">## often see them absent from the map encoding a StructField.  This is because</span>
<span class="token comment">## these fields are specified to be implicitly false.</span>
<span class="token comment">## Implicits in a map representation of a struct mean that those entries may</span>
<span class="token comment">## be missing from the map encoding... but unlike with &quot;optional&quot; fields, there</span>
<span class="token comment">## is no &quot;undefined&quot; value; absence is simply interpreted as the value specified</span>
<span class="token comment">## as the implicit.</span>
<span class="token comment">## (With implicit fields, an explicitly encoded implicit value is actually an</span>
<span class="token comment">## error instead!)  &quot;Optional&quot; fields give rise to N+1 cardinality logic,</span>
<span class="token comment">## just like &quot;nullable&quot; fields; &quot;implicit&quot; fields *do not*.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">StructField</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
<span class="token typedef"><span class="token keyword">	type</span> <span class="token class-name">TypeTerm</span></span>
	optional Bool <span class="token punctuation">(</span>implicit <span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span>
	nullable Bool <span class="token punctuation">(</span>implicit <span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span>
<span class="token representation">} <span class="token builtin">representation</span></span> map

<span class="token comment">## TypeTerm is a union of either TypeName or an InlineDefn. th It's used for the</span>
<span class="token comment">## value type in the recursive types (maps, lists, and the fields of structs),</span>
<span class="token comment">## which allows the use of InlineDefn in any of those positions.</span>
<span class="token comment">##</span>
<span class="token comment">## TypeTerm is simply a TypeName if the kind of data is a string; this is the</span>
<span class="token comment">## simple case.</span>
<span class="token comment">##</span>
<span class="token comment">## Note that TypeTerm isn't used to describe *keys* in the recursive types that</span>
<span class="token comment">## have them (maps, structs) -- recursive types in keys would not lend itself</span>
<span class="token comment">## well to serialization!</span>
<span class="token comment">## TypeTerm also isn't used to describe members in Unions -- this is a choice</span>
<span class="token comment">## aimed to limit syntactical complexity (both at type definition authoring</span>
<span class="token comment">## time, as well as for the sake of error messaging during typechecking).</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeTerm</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> TypeName <span class="token keyword">string</span>
	<span class="token punctuation">|</span> InlineDefn map
<span class="token representation">} <span class="token builtin">representation</span></span> kinded

<span class="token comment">## InlineDefn represents a declaration of an anonymous type of one of the simple</span>
<span class="token comment">## recursive kinds (e.g. map or list) which is found &quot;inline&quot; in another type's</span>
<span class="token comment">## definition.  It's the more complex option of the TypeTerm union.</span>
<span class="token comment">##</span>
<span class="token comment">## Note that the representation of this union -- `representation inline &quot;kind&quot;`</span>
<span class="token comment">## -- as well as the keywords for its members -- align exactly with those</span>
<span class="token comment">## in the Type union.  Technically, this isn't a necessary property (in that</span>
<span class="token comment">## nothing would break if that sameness was violated) but it's awfully nice for</span>
<span class="token comment">## sanity; what we're saying here is that the representation of the types in an</span>
<span class="token comment">## InlineDefn should look *exactly the same* as the top-level Types... it's just</span>
<span class="token comment">## that we're restricted to a subset of the members.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">InlineDefn</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> TypeMap <span class="token string">&quot;map&quot;</span>
	<span class="token punctuation">|</span> TypeList <span class="token string">&quot;list&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> inline <span class="token punctuation">{</span>
	discriminantKey <span class="token string">&quot;kind&quot;</span>
<span class="token punctuation">}</span>

<span class="token comment">## StructRepresentation describes how a struct type should be mapped onto</span>
<span class="token comment">## its IPLD Data Model representation.  Typically, maps are the representation</span>
<span class="token comment">## kind, but other kinds and details can be configured.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">StructRepresentation</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> StructRepresentation_Map <span class="token string">&quot;map&quot;</span>
	<span class="token punctuation">|</span> StructRepresentation_Tuple <span class="token string">&quot;tuple&quot;</span>
	<span class="token punctuation">|</span> StructRepresentation_StringPairs <span class="token string">&quot;stringpairs&quot;</span>
	<span class="token punctuation">|</span> StructRepresentation_StringJoin <span class="token string">&quot;stringjoin&quot;</span>
	<span class="token punctuation">|</span> StructRepresentation_ListPairs <span class="token string">&quot;listpairs&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> keyed

<span class="token comment">## StructRepresentation_Map describes a way to map a struct type onto a map</span>
<span class="token comment">## representation. Field serialization options may optionally be configured to</span>
<span class="token comment">## enable mapping serialized keys using the 'rename' option, or implicit values</span>
<span class="token comment">## specified where the field is omitted from the serialized form using the</span>
<span class="token comment">## 'implicit' option.</span>
<span class="token comment">##</span>
<span class="token comment">## See StructRepresentation_Map_FieldDetails for details on the 'rename' and</span>
<span class="token comment">## 'implicit' options.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">StructRepresentation_Map</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	fields optional <span class="token punctuation">{</span>FieldName<span class="token punctuation">:</span>StructRepresentation_Map_FieldDetails<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">## StructRepresentation_Map_FieldDetails describes additional properties of a</span>
<span class="token comment">## struct field when represented as a map.  For example, fields may be renamed,</span>
<span class="token comment">## or implicit values associated.</span>
<span class="token comment">##</span>
<span class="token comment">## If an implicit value is defined, then during marshalling, if the actual value</span>
<span class="token comment">## is the implicit value, that field will be omitted from the map; and during</span>
<span class="token comment">## unmarshalling, correspondingly, the absence of that field will be interpreted</span>
<span class="token comment">## as being the implicit value.</span>
<span class="token comment">##</span>
<span class="token comment">## Note that fields with implicits are distinct from fields which are optional!</span>
<span class="token comment">## The cardinality of membership of an optional field is is incremented:</span>
<span class="token comment">## e.g., the cardinality of &quot;fieldname Bool&quot; is 2; &quot;fieldname optional Bool&quot; is</span>
<span class="token comment">## membership cardinality *3*, because it may also be undefined.</span>
<span class="token comment">## By contrast, the cardinality of membership of a field with an implicit value</span>
<span class="token comment">## remains unchanged; there is serial state which can map to an undefined value.</span>
<span class="token comment">##</span>
<span class="token comment">## Note that 'rename' supports exactly one string, and not a list: this is</span>
<span class="token comment">## intentional.  The rename feature is meant to allow serial representations</span>
<span class="token comment">## to use a different key string than the schema type definition field name;</span>
<span class="token comment">## it is not intended to be used for migration purposes.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">StructRepresentation_Map_FieldDetails</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	rename optional String
	implicit optional AnyScalar
<span class="token punctuation">}</span>

<span class="token comment">## StructRepresentation_Tuple describes a way to map a struct type into a list</span>
<span class="token comment">## representation.</span>
<span class="token comment">##</span>
<span class="token comment">## Tuple representations are less flexible than map representations:</span>
<span class="token comment">## field order can be specified in order to override the order defined</span>
<span class="token comment">## in the type, but optionals and implicits are not (currently) supported.</span>
<span class="token comment">## A `fieldOrder` list must include quoted strings (FieldName is a string</span>
<span class="token comment">## type) which are coerced to the names of the struct fields. e.g.:</span>
<span class="token comment">##   fieldOrder [&quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot;]</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">StructRepresentation_Tuple</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	fieldOrder optional <span class="token punctuation">[</span>FieldName<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">## StructRepresentation_StringPairs describes that a struct should be encoded</span>
<span class="token comment">## as a string of delimited &quot;k/v&quot; entries, e.g. &quot;k1=v1,k2=v2&quot;.</span>
<span class="token comment">## The separating delimiter may be specified with &quot;entryDelim&quot;, and the k/v</span>
<span class="token comment">## delimiter may be specified with &quot;innerDelim&quot;. So a &quot;k=v&quot; naive</span>
<span class="token comment">## comma-separated form would use an &quot;innerDelim&quot; of &quot;=&quot; and an &quot;entryDelim&quot;</span>
<span class="token comment">## of &quot;,&quot;.</span>
<span class="token comment">##</span>
<span class="token comment">## Serialization a struct with stringpairs works the same way as serializing</span>
<span class="token comment">## a map with stringpairs and the same character limitations exist. See</span>
<span class="token comment">## MapRepresentation_StringPairs for more details on these limitations.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">StructRepresentation_StringPairs</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	innerDelim String
	entryDelim String
<span class="token punctuation">}</span>

<span class="token comment">## StructRepresentation_StringJoin describes a way to encode a struct to</span>
<span class="token comment">## a string in the IPLD Data Model. Similar to tuple representation, the</span>
<span class="token comment">## keys are dropped as they may be inferred from the struct definition.</span>
<span class="token comment">## values are concatenated, in order, and separated by a &quot;join&quot; delimiter.</span>
<span class="token comment">## For example, specifying &quot;:&quot; as the &quot;join&quot;: &quot;v1,v2,v3&quot;.</span>
<span class="token comment">##</span>
<span class="token comment">## stringjoin is necessarily restrictive and therefore only valid for structs</span>
<span class="token comment">## whose values may all be encoded to string form without conflicts in &quot;join&quot;</span>
<span class="token comment">## character. It is recommended, therefore, that its use be limited to structs</span>
<span class="token comment">## containing values with the basic data model kinds that exclude multiple</span>
<span class="token comment">## values (i.e. no maps, lists, and therefore structs or unions).</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">StructRepresentation_StringJoin</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	join String
	fieldOrder optional <span class="token punctuation">[</span>FieldName<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">## StructRepresentation_ListPairs describes that a struct, should be encoded as</span>
<span class="token comment">## a list in the IPLD Data Model. This list comprises a sub-list for each</span>
<span class="token comment">## entry, in the form: [[k1,v1],[k2,v2]].</span>
<span class="token comment">##</span>
<span class="token comment">## This representation type encodes in the same way as</span>
<span class="token comment">## MapStructRepresentation_Tuple. It is also similar to</span>
<span class="token comment">## StructRepresentation_Tuple except it includes the keys in nested lists.</span>
<span class="token comment">## A tuple representation for a struct will encode more compact than listpairs.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">StructRepresentation_ListPairs</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">## TypeEnum describes a type which has a known, pre-defined set of possible</span>
<span class="token comment">## values. Each of the values must be representable as a string (EnumValue)</span>
<span class="token comment">## when using the default &quot;string&quot; representation, or when using an &quot;int&quot;</span>
<span class="token comment">## representation, an integer must also be supplied along with the EnumValue.</span>
<span class="token comment">##</span>
<span class="token comment">## Integer and string values (for int and string representations respectively)</span>
<span class="token comment">## are provided in parens in the DSL. Where the string used in serialization is</span>
<span class="token comment">## the same as the EnumValue, it may be omitted. For int representation enums,</span>
<span class="token comment">## all int values are required.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeEnum</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  members <span class="token punctuation">{</span>EnumValue<span class="token punctuation">:</span>Null<span class="token punctuation">}</span>
	representation EnumRepresentation
<span class="token punctuation">}</span>

<span class="token comment">## EnumValue is a string that has limitations for use as a member of an enum</span>
<span class="token comment">## set. The rules for EnumValue are the same as for TypeName but without the</span>
<span class="token comment">## convention of an uppercase first character. Capitalization is left up to</span>
<span class="token comment">## the user.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">EnumValue</span></span> <span class="token keyword">string</span>

<span class="token comment">## EnumRepresentation describes how an enum type should be mapped onto</span>
<span class="token comment">## its IPLD Data Model representation. By default an enum is represented as a</span>
<span class="token comment">## string kind but it may also be represented as an int kind.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">EnumRepresentation</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
	<span class="token punctuation">|</span> EnumRepresentation_String <span class="token string">&quot;string&quot;</span>
	<span class="token punctuation">|</span> EnumRepresentation_Int <span class="token string">&quot;int&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> keyed

<span class="token comment">## EnumRepresentation_String describes the way an enum is represented as a</span>
<span class="token comment">## string in the data model. By default, the strings used as EnumValue will be</span>
<span class="token comment">## used at the serialization. A custom string may be provided (with `Foo (&quot;x&quot;)`</span>
<span class="token comment">## in the DSL) which will be stored here in the representation block. Missing</span>
<span class="token comment">## entries in this map will use the default.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">EnumRepresentation_String</span></span> <span class="token punctuation">{</span>EnumValue<span class="token punctuation">:</span>String<span class="token punctuation">}</span>

<span class="token comment">## EnumRepresentation_Int describes the way an enum is represented as an int</span>
<span class="token comment">## in the data model. A mapping of names to ints is required to perform the</span>
<span class="token comment">## conversion from int to enum value. In the DSL, int values _must_ be provided</span>
<span class="token comment">## for each EnumValue (with `Foo (&quot;100&quot;)`, those are stored here.</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">EnumRepresentation_Int</span></span> <span class="token punctuation">{</span>EnumValue<span class="token punctuation">:</span>Int<span class="token punctuation">}</span>

<span class="token comment">## TypeCopy describes a special &quot;copy&quot; unit that indicates that a type name</span>
<span class="token comment">## should copy the type descriptor of another type. TypeCopy does not redirect a</span>
<span class="token comment">## name to another type. Instead, it copies the entire type definition and</span>
<span class="token comment">## assigns it to another type.</span>
<span class="token comment">##</span>
<span class="token comment">## The DSL defines a TypeCopy as `type NewThing = CopiedThing`, where</span>
<span class="token comment">## &quot;CopiedThing&quot; refers to a `type` defined elsewhere in a schema and is not</span>
<span class="token comment">## one of TypeKind or an inline type descriptor (`{}`, `[]`, `&amp;`).</span>
<span class="token comment">##</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">TypeCopy</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
	fromType TypeName
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/specs/assets/js/app.0a49797f.js" defer></script><script src="/specs/assets/js/2.1a099048.js" defer></script><script src="/specs/assets/js/19.793dfca8.js" defer></script>
  </body>
</html>
